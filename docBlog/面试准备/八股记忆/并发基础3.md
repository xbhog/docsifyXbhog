## 并发编程的三个重要特性：

1. 原子性：要么所有的操作都执行，要么都不执行。Synchronized可以保证
2. 可见性：`volatile` 可以保证共享变量的可见性
3. 有序性：`volatile` 关键字可以禁止指令进行重排序优化。

什么是指令重排：在计算机中，为了让CPU提高运算效率，处理器可能会对输入的代码进行【乱序执行】，也就是所谓的【指令重排序】；

## 说说 synchronized 关键字和 volatile 关键字的区别

1. volatile关键字是线程同步的轻量级实现，但只能使用在变量上，Synchronized可以使用在方法、代码块的部分；
2. volatile只能保证可见性，而synchronized可以保证原子性和可见性
3. volatile主要解决变量在多个线程之间的可见性，synchronized可以解决多个线程之间访问资源的同步性。

## Java内存模型

Java为了屏蔽硬件和操作系统访问内存的各种差异，提出了「Java内存模型」的规范，保证了Java程序在各种平台下对内存的访问都能得到一致效果。

Java内存模型分为：

1. Java内存模型的抽象结构
2. happen-before规则
3. volatile

Java内存模型定义了Java线程对内存数据进行交互的规范，线程之间的【共享变量】存储在主内存中，每个线程都有自己私有的本地内存，本地内存存储了线程以读/写共享变量的副本。

> Java内存模型规定了：线程对变量的所有操作都必须在「本地内存」进行，「不能直接读写主内存」的变量

其中happen-before规则为了解决「操作之间」的内存「可见性」，在CPU和编译器上有指令重排的问题。

由于希望某些操作的结果由我们来掌握，所以该操作不能进行重排序，前面一个操作的结果对后续操作必须是可见的。

所以才有了happen-before规则。