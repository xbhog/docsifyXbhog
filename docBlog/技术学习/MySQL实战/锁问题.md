# 数据库锁问题

> 根据加锁的范围，MySQL里面的锁大致分为全局锁、表锁、行锁三类

## 全局锁

实现：对整个**数据库实例**进行加锁，使用FTWRL.

```sql
Flush table with read lock
```

效果：整个库处于只读状态，DML和DDL以及更新事务的提交语句都会被阻塞。

全局锁使用场景：做全库逻辑备份(binlog)--也就是把整库每个表都 select 出来存成文本

做全库逻辑备份：

1. 加全局锁：整个库处于阻塞状态，无法更新，这对线上是不可能采用的
2. 不加全局锁：当我在备份的时候，由数据更新，造成，备份库和本地库不匹配，没有意义

准确点说：

> 不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的

由此，可以引出前面所说的事务隔离中的可重复读：

一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是 一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。

*MySQL多版本并发控制(MVCC):同一条记录在系统中可以存在多个版本，不同时刻启动的事务会有不同的read-view(值)。*

具体的实现是：

官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 **MVCC** 的支持，这个过程中数据是可以正常更新的。

FTWRL与single-transaction对比：

1. FTWRL：适用于不支持事务的引擎；并且使用后如果客户端发生异常连接断开，那么MySQL会自动释放全局锁。
2. single-transaction：**所有的表使用事务引擎的库**(InnoDB )

为了使全库已读，也不推荐：**set global readonly=true**

- 一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用。
- 二是，将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高

## 表级锁(表锁)